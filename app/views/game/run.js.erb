hide_progress_message()

// console.log("run.js.erb called")
console.log('Simulation results:','<%= escape_javascript(@result) %>')

clearTheBoard()
var ant_nodes = [] //for the d3 animation version. This could probably be cleaner...

var all_ants = <%= javascript_ants %> //get the ants from ruby atm
var active_ants = all_ants.slice() //all ants are initially active
// for(var i=0, len=all_ants.length; i<len; i++){
// 	islands[all_ants[i].island].addAnt(all_ants[i])
// }
console.log('all_ants', all_ants)


startAnimation(paper) //may not need to be a method...

/***
eventually move this all into the main .js file, for faster loading (?)
***/

//define ant object prototype
function Ant(n,plan,island){
	this.n = n
	this.plan = plan
	this.stat = 0
	this.path = -1
	this.pathlen = 0
	this.prog = 0
	this.reverse = false
	this.island = island
	islands[island].addAnt(this,false)
	this.pos = {x:currNodes[island].x, y:currNodes[island].y}
	this.icon = paper.circle(this.pos.x, this.pos.y,3)
		.attr({'fill':'#0f0'})
	ant_nodes.push(this.icon.node)
}
Ant.prototype.WAITING = 0;
Ant.prototype.ON_PATH = 1;
Ant.prototype.ON_WRONG_PATH = 2;
Ant.prototype.GETTING_LOST = 3;
Ant.prototype.SWIMMING = 4;
Ant.prototype.ARRIVED = 5;
Ant.prototype.GOING_HOME = 6;
Ant.prototype.DANCING = 7;
Ant.prototype.DONE = 8;
Ant.prototype.SETTLED = 9;
Ant.prototype.DEAD = 10;

Ant.prototype.tick = function(){
	if(this.stat == this.ARRIVED){
		this.arrive()
	}
	else if(this.stat == this.WAITING){ //waiting for a path...
		this.pace()
	}
	else if(this.stat == this.ON_PATH){
		this.walkPath()
	}
	else if(this.stat == this.ON_WRONG_PATH){
		this.wrongPath()
	}
	else if(this.stat == this.GETTING_LOST){
		this.getLost()
	}
	else if(this.stat == this.DANCING){
		this.victoryDance()
	}
	else if(this.stat == this.GOING_HOME){
		this.settleDown()
	}
}
Ant.prototype.walkPath = function(){
	this.prog += 10; //take a step (sizable)
	if(this.prog < this.pathlen){ //if we're still on the path
		if(this.reverse)
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.pathlen - this.prog);
		else
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.prog);
	}
	else{ //we arrived
		if(this.reverse)
			this.island = currEdges[this.path].a.id;
		else
			this.island = currEdges[this.path].b.id;
		islands[this.island].addAnt(this,true) //set our new island (and we came from a journey). That will set our status
	}
}
Ant.prototype.wrongPath = function(){
	this.prog += 10; //take a step (sizable)
	if(this.prog*2 < this.pathlen){ //if we're less than halfway, walk as normal
		if(this.reverse)
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.pathlen - this.prog);
		else
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.prog);
	}
	else{ //otherwise, get lost!
		this.stat = this.GETTING_LOST
		this.prog = 0
		this.icon.attr({'fill':'#A63E3E'})
	}
}
Ant.prototype.getLost = function(){
	this.prog += 1
	if(this.prog%3==0){
		this.randomWalk(4)
		this.icon.attr({'opacity':1-(this.prog/100)})
	}	
	else if(this.prog > 60){
		this.stat = this.DEAD
		this.prog = 0
		this.icon.attr({'opacity':0.6})
		this.icon.toBack()
	}
}
Ant.prototype.randomWalk = function(step){
	this.pos = {x:this.pos.x+(Math.random()*step*2-step), y:this.pos.y+(Math.random()*step*2-step)}
}
Ant.prototype.pace = function(){

}
Ant.prototype.goSwimming = function(){

}
Ant.prototype.arrive = function(){
	this.stat = this.DANCING //start dancing
	this.prog = 0
	this.icon.attr({'fill':'#3CA03C'});
}
Ant.prototype.victoryDance = function(){
	this.prog += 1
	if(this.prog > 45){
		this.stat = this.GOING_HOME //settle down
		this.prog = 0
	}
	else if(this.prog%20 < 10){
		this.pos = {x:this.pos.x, y:this.pos.y-0.3} //bounce up
		this.icon.attr({'cx':this.pos.x, 'cy':this.pos.y})
	}
	else if(this.prog%20 < 20){
		this.pos = {x:this.pos.x, y:this.pos.y+0.3} //bounce down
		this.icon.attr({'cx':this.pos.x, 'cy':this.pos.y})
	}
}
Ant.prototype.settleDown = function(){
	this.prog += 1
	if(this.prog == 1)
		this.icon.insertBefore(islands[this.island].icon[2]) //move the ant behind the house (currently #2)
	if(this.prog <= 4){
		var vx = .25*(currNodes[this.island].x - this.pos.x) //quarter of the distance to the center
		var vy = .25*(currNodes[this.island].y - this.pos.y)
		this.pos = {x:this.pos.x+vx, y:this.pos.y+vy}
		this.icon.attr({'cx':this.pos.x, 'cy':this.pos.y})
	}
	else{
		this.stat = this.SETTLED //stop moving for future ticks
		this.prog = 0
		this.icon.insertBefore(islands[this.island].icon[3]) //move behind the coast to hide entirely
		//console.log(this.n, 'settled down at', currNodes[this.island].name)
	}
}

//removes all the ants
function clearTheBoard(){
	for(i in islands){ //reset the islands
		islands[i].reset()
	}
	
	if(typeof all_ants !== 'undefined') {
		console.log("clearing ants on subsequent run")
		for(var i=0, len=all_ants.length; i<len; i++)
			all_ants[i].icon.remove()
	}
}

function startAnimation(paper) {
	console.log('starting animation')
	console.log('anim islands',islands)
	//block out all the other interactions so that the user doesn't break things
	//var block = paper.rect(0,0,paper.width,paper.height).attr({'opacity':0, 'fill-opacity':0,'stroke-width':0})

	// var d3nodes = d3.selectAll(ant_nodes)
	var count = 0
	
	animator = setInterval(function() {

		//raphael implementation
		for(key in islands){
			islands[key].tick() //tick the islands, who spawn and deploy their ants
		}

		inactive = []
		for(var i=0, len=active_ants.length; i<len; i++){
			active_ants[i].tick() //do what they do!
			active_ants[i].icon.attr({'cx':active_ants[i].pos.x, 'cy':active_ants[i].pos.y})
			// active_ants[i].icon.animate({'cx':active_ants[i].pos.x, 'cy':active_ants[i].pos.y},10) //can be replaced with d3
			if(active_ants[i].stat == active_ants[i].DONE || 
				 active_ants[i].stat == active_ants[i].SETTLED || 
				 active_ants[i].stat == active_ants[i].DEAD){ //if we're done, we shouldn't be in this list!
				inactive.push(active_ants[i]) //prepare to drop anyone who is done
			}
		}
		for(var i=0, len=inactive.length; i<len; i++){
			active_ants.splice(active_ants.indexOf(inactive[i]),1)
		}

		//d3 implementation, for potentially smoother animation? Doesn't seem to help much, as we're doing complex calculations.
		// http://stackoverflow.com/questions/8239235/smoothly-animate-attribute-changes-to-3000-raphael-objects-at-once
		// http://jsfiddle.net/ekMd6/
		// d3nodes
		// 	.transition()
		// 	.attr('cx', function(d,i){return ants[i].pos.x;})
		// 	.attr('cy', function(d,i){return ants[i].pos.y;})
		// 	.duration(1)

		// console.log('step',count, done)
		count += 1;
		if(active_ants.length == 0 || count > 100){
			console.log('done animating at count',count)
			clearInterval(animator);
			
			//show the score after animation is done (or before?)
			$('#score_content').html('Your score: <%= escape_javascript(@result) %>');
			$('#score_notice').toggle(true);
			
			if(typeof block !== 'undefined')
				block.remove()
			
			console.log('#actives',active_ants.length)
			
			// console.log('island_ants',island_ants) //not very helpful actually...
			//console.log('islands', islands)
			
		}
	}, 30);

}

