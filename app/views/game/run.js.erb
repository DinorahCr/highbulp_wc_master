hide_progress_message()

// console.log("run.js.erb called")
console.log('Simulation results:','<%= escape_javascript(@result) %>')

var ant_nodes = [] //for the d3 animation version. This could probably be cleaner...

if(typeof my_ants !== 'undefined') {
	console.log("clearing ants on second run")
	for(var i=0, len=my_ants.length; i<len; i++)
		my_ants[i].icon.remove()
}
var island_ants = {} //the islands the ants are on

<%= javascript_ants %> //get the ants
console.log('my_ants', my_ants)

animateAnts(paper, my_ants)

/***
eventually move this all into the main .js file, for faster loading (?)
***/

//define ant object prototype
function Ant(n,plan,island){
	this.n = n
	this.plan = plan
	this.stat = 0
	this.path = -1
	this.pathlen = 0
	this.prog = 0
	this.reverse = false
	this.island = island
	if(typeof island_ants[this.island]==='undefined')
		island_ants[this.island] = {}
	island_ants[this.island][this.n] = this.n //add to the island list on creation
	this.pos = {x:currNodes[island].x, y:currNodes[island].y}
	this.icon = paper.circle(this.pos.x, this.pos.y,3)
		.attr({'fill':'#0f0'})
	ant_nodes.push(this.icon.node)
}
Ant.prototype.DECIDING = 0;
Ant.prototype.SETTLED = 1;
Ant.prototype.ON_PATH = 2;
Ant.prototype.ON_WRONG_PATH = 3;
Ant.prototype.GETTING_LOST = 4;
Ant.prototype.SWIMMING = 5;

Ant.prototype.tick = function(){
	if(this.stat == this.SETTLED)
		return true; //we're done
	
	if(this.stat == this.DECIDING){ //pick a path
		if(this.plan.length > 0){
			this.path = this.plan.shift()
			if(this.path < 0){
				this.path = -1*this.path
				this.stat = this.ON_WRONG_PATH
			}
			else{
				this.stat = this.ON_PATH
			}
			this.pathlen = edgeIcons[this.path][0].getTotalLength()
			this.prog = 0
			//figure out if we're moving the reverse of the path or not--if our island is the b item on the path we're taking
			this.reverse = (this.island == currEdges[this.path].b.id)
			// console.log(this.n,'starting on new path',this.path,'from', this.island, this.plan, this.reverse)
		}
		else{
			this.settleDown()
		}
	}
	
	if(this.stat == this.ON_PATH){
		this.walkPath()
	}
	else if(this.stat == this.ON_WRONG_PATH){
		this.wrongPath()
	}
	else if(this.stat == this.GETTING_LOST){
		this.getLost()
	}
	
	return false; //we're still going
}

Ant.prototype.walkPath = function(){
	this.prog += 10; //take a step (sizable)
	if(this.prog < this.pathlen){ //if we're still on the path
		if(this.reverse)
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.pathlen - this.prog);
		else
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.prog);
	}
	else{
		delete island_ants[this.island][this.n] //remove us from the last old island list

		if(this.reverse)
			this.island = currEdges[this.path].a.id;
		else
			this.island = currEdges[this.path].b.id;
		
		if(typeof island_ants[this.island]==='undefined')
			island_ants[this.island] = {}
		island_ants[this.island][this.n] = this.n //add to the island list when we get somewhere

		this.stat = this.DECIDING;
	}
}

Ant.prototype.wrongPath = function(){
	this.prog += 10; //take a step (sizable)
	if(this.prog*2 < this.pathlen){ //if we're less than halfway, walk as normal
		if(this.reverse)
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.pathlen - this.prog);
		else
			this.pos = edgeIcons[this.path][0].getPointAtLength(this.prog);
	}
	else{ //otherwise, get lost!
		this.prog = 0
		this.icon.attr({'fill':'#A63E3E'})
		this.stat = this.GETTING_LOST
	}
}

Ant.prototype.getLost = function(){
	this.prog += 1
	if(this.prog%3==0){
		this.randomWalk(4)
		this.icon.attr({'opacity':1-(this.prog/100)})
	}	
	else if(this.prog > 60){
		this.icon.attr({'opacity':0.6})
		this.icon.toBack()
		this.stat = this.SETTLED
	}
}

Ant.prototype.pace = function(){

}

Ant.prototype.goSwimming = function(){

}

Ant.prototype.randomWalk = function(step){
	this.pos = {x:this.pos.x+(Math.random()*step*2-step), y:this.pos.y+(Math.random()*step*2-step)}
}

Ant.prototype.settleDown = function(){
	this.stat = this.SETTLED //stop moving for future ticks	
	this.pos = {x:currNodes[this.island].x+Math.random()*16-8, y:currNodes[this.island].y+Math.random()*16-8} 	
	this.icon.attr({'cx':this.pos.x, 'cy':this.pos.y, 'fill':'#3CA03C'})
	// console.log(this.n, 'settled down at', currNodes[this.island].name)
}


function Island(n,opt_degree){
	this.n = n
	this.degree = opt_degree //how many edges we WANT to have coming out of us...
	this.bridges = []
	this.ants = []
	this.node = currNodes[this.n]
	this.icon = nodeIcons[this.n]
}
Island.prototype.addAnt = function(ant){
	//add an ant to the island (so ants can add themselves when they arrive)
}
Island.prototype.spawnAnt = function(){
	//create a new ant on this island
}
Island.prototype.deployAnt = function(){
	//deploy an ant along an edge
}
Island.prototype.updatePos = function(){dx,dy} //update the position based on the node/icon/etc (move collected ants)
Island.prototype.updateEdges = function(){} //update the edges (brid)


function animateAnts(paper, ants) {
	console.log('drawing ants')
	//block out all the other interactions so that the user doesn't break things
	var block = paper.rect(0,0,paper.width,paper.height).attr({'opacity':0, 'fill-opacity':0,'stroke-width':0})

	var d3nodes = d3.selectAll(ant_nodes)
	var count = 0
	
	animator = setInterval(function() {

		var done = true
		//raphael implementation
		for(var i=0, len=ants.length; i<len; i++){
			done = ants[i].tick() && done //do what they do!
			ants[i].icon.attr({'cx':ants[i].pos.x, 'cy':ants[i].pos.y})
			// ants[i].icon.animate({'cx':ants[i].pos.x, 'cy':ants[i].pos.y},10) //do all the animations in here; can be replaced with d3
		}

		//d3 implementation, for potentially smoother animation? Doesn't seem to help much, as we're doing complex calculations.
		// http://stackoverflow.com/questions/8239235/smoothly-animate-attribute-changes-to-3000-raphael-objects-at-once
		// http://jsfiddle.net/ekMd6/
		// d3nodes
		// 	.transition()
		// 	.attr('cx', function(d,i){return ants[i].pos.x;})
		// 	.attr('cy', function(d,i){return ants[i].pos.y;})
		// 	.duration(1)

		// console.log('step',count, done)
		count += 1;
		if(done || count > 500){
			console.log('done animating')
			clearInterval(animator);
			// for(var i=0, len=ants.length; i<len; i++)
			// 	ants[i].icon.remove()
			
			//show the score after animation is done (or before?)
			$('#score_content').html('Your score: <%= escape_javascript(@result) %>');
			$('#score_notice').toggle(true);
			
			block.remove()
			
			// console.log('island_ants',island_ants) //not very helpful actually...
			
		}
	}, 10);

}

